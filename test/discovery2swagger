#!/usr/bin/env node
'use strict';

const assert = require('assert');
const _ = require('lodash');
const async = require('async')
const Request = require('request');
const fs = require('fs');
const mkdirp = require('mkdirp').sync;
const discoveryToOpenAPI = require('../src/index.js');
discoveryToOpenAPI.setStrict(true);
const validator = require('oas-validator');

if (!process.argv[2]) {
  console.log('missing directory name');
  process.exit(1);
}

mkdirp(process.argv[2]);
process.chdir(process.argv[2]);

new Request('https://www.googleapis.com/discovery/v1/apis', function(err, response, data) {
  assert(!err);
  assert(response.statusCode === 200, 'Can not GET API list: ' + response.statusMessage);
  processList(data);
});

function processList(data) {
  data = JSON.parse(data);
  assert.equal(data.kind, 'discovery#directoryList');
  assert.equal(data.discoveryVersion, 'v1');

  //FIXME: data.preferred
  async.mapSeries(data.items, function (api, asyncCb) {
    console.log('Downloading ' + api.discoveryRestUrl + ' ...');
    new Request(api.discoveryRestUrl, function(err, response, data) {
      if (err)
        return asyncCb(err);
      if (response.statusCode !== 200)
        return asyncCb(Error('Can not GET ' + api.discoveryRestUrl + ': ' + response.statusMessage));
      asyncCb(null, data);
    });
  }, function (error, apis) {
    //assert(!error);
    _.each(apis, processAPI);
  });
}

function processAPI(data) {
  if (!data) return false;
  data = JSON.parse(data);
  assert.equal(data.kind, 'discovery#restDescription');

  //blacklist
  if ([
         //missing API description
         'cloudlatencytest:v2',
         //asterisk in path
         'admin:directory_v1',
         //plus in path
         //'pubsub:v1',
         //'pubsub:v1beta1',
         //'pubsub:v1beta1a',
         //'pubsub:v1beta2',
         //'genomics:v1',
         //'appengine:v1beta4',
         //'storagetransfer:v1',
         //'cloudbilling:v1',
         //'proximitybeacon:v1beta1',
         //circular reference in MapFolder/MapItem
         'mapsengine:exp2',
         'mapsengine:v1',
       ].indexOf(data.id) >= 0) {
      return;
  }

  console.log('Processing: ' + data.id);
  var openapi = discoveryToOpenAPI.convert(data);

  validateOpenAPI(openapi, function (str) {
    saveOpenAPI(data.name, data.version, str);
  });
}

function saveOpenAPI(name, version, openapi) {
  var path = name + '/';
  mkdirp(path);
  path += version + '/';
  mkdirp(path);
  path += 'openapi.json';
  var strOpenAPI = JSON.stringify(openapi, null, 2);
  fs.writeFileSync(path, strOpenAPI);
  console.log(path);
}

function validateOpenAPI(openapi, cb) {
  validator.validate(openapi, {})
  .then(options => {
    if (!options.valid) {
      console.log(JSON.stringify(openapi, null, 2));
      console.log(JSON.stringify(validationResults.errors, null, 2));
      process.exit(1);
    }
    cb(openapi);
  })
  .catch(validationError => {
      console.log(validationError);
      process.exit(1);
  });
}
